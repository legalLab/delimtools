---
title: "Introduction to delimtools"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Introduction to delimtools}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
library(ape)
library(delimtools)
library(dplyr)
library(here)
```

##

# Rationale

There are at least three major steps when doing single-locus species delimitation analysis:

* Preparing your data;  
    
* Running species delimitation analysis;  
    
* Visualizing results.

The rationale of `delimtools` is to provide helper functions for all these steps. This guide introduces you to these functions and shows how to apply them to your datasets. In this tutorial, we will use the `geophagus` dataset provided in this package. This dataset contains `r length(geophagus)` cytochrome c oxidase sequences of the *Geophagus sensu stricto* species group downloaded from GenBank. Most of these sequences are from the data analysed by Ximenes et al. (2021) and is documented in `?geophagus`.

## Preparing your data
Usually, our main source of information for single-locus species delimitation 
analysis is a [FASTA](https://www.ncbi.nlm.nih.gov/genbank/fastaformat/) formated 
file containing nucleotide sequences. The most straighforward way to import a 
FASTA formated file to R Environment is by using `ape::read.FASTA()`:

```{r eval=FALSE}
path_to_file <- system.file("extdata/geophagus.fasta", package = "delimtools")

geophagus <- ape::read.FASTA(file= path_to_file)

```

Since `geophagus` dataset is provided along with `delimtools`, one can simply
call it directly:

```{r}
geophagus
```

### Check identifiers across files

Although the header of each sequence in a FASTA file may contain information about
the source organism from which the sequence was obtained, we recommend storing 
this information in a tabular format file (e.g. `csv`, `tsv`, `xlsx`, etc.), using
an unique sequence identifier for both FASTA and tabular files. We can 
have a glimpse of our sequence metadata by checking `geophagus_info`:

```{r}
dplyr::glimpse(geophagus_info)
```

It's desirable that both our FASTA file and our metadata have the same dimensions 
and no abscent, mistyped, or duplicated sequence identifiers within and between 
these files. Let's check if our FASTA file and our metadata has the same sequence identifiers
using `delimtools::check_identifiers()`:

```{r}
check_identifiers(data= geophagus_info, identifier= "gbAccession", dna= geophagus)
```

Now, let's omit the first 10 sequences and check again:

```{r error= TRUE}
check_identifiers(geophagus_info, "gbAccession", geophagus[11:354])
```

**Notice** that `check_identifiers` will not evaluate if sequence identifiers in FASTA and metadata
appears in the same order:

```{r}
identical(names(geophagus), geophagus_info$gbAccession)

all.equal(names(geophagus), geophagus_info$gbAccession)
```

Many other functions of `delimtools` relies on a tabular format file like `geophagus_info`, 
so please make sure to have one prior to any analysis.

### Cleaning DNA and Haplotype Collapsing

Sometimes, our alignment file may contain non *ACTG * bases, like ambiguities (N, R, Y, etc),
gaps (-), or missing data (?) which may have unintended consequences later. Using `clean_dna`,
we can find which sequences may need further manual checking.

```{r}
clean_dna(geophagus)
```

**Notice** that `clean_dna` will remove both leading and trailing gaps from the alignment, being
necessary to realign the file after that. 

The presence of identical sequences (haplotypes) in our dataset may overestimate the number of lineages 
detected by tree-based species delimitation methods (e.g. bGMYC, GMYC, PTP, mPTP). Prior to phylogenetic 
tree inference for these analyses, it is a best practice to remove (collapse) these sequences into its 
unique haplotypes. To collapse an alignment into its unique haplotypes, you may use the `hap_collapse` function with
default settings:

```{r}
hap_collapse(geophagus, clean= TRUE, collapseSubstrings = TRUE)
```

**Notice** that from the initial 354 DNA sequences, `hap_collapse` returned a total of 137 unique DNA sequences. This result may vary if setting `collapseSubstrings` to `FALSE`:

```{r}
hap_collapse(geophagus, clean=TRUE, collapseSubstrings = FALSE)
```

After setting `collapseSubstrings` to `FALSE`, we obtained 246 unique DNA sequences. These additional 109 sequences are in reality shorter but identical sequences which in most cases varies only by the presence of leading and trailing gaps. 
By setting both `clean_dna` and `collapseSubstrings` to `TRUE`, we ensure the removal of these leading and trailing gaps 
from sequences before collapsing these sequences into unique haplotypes.

**Warning:** be carefull when using `collapseSubstrings` when using non-coding genes (e.g. 12S/16S rRNAs)

To visualize the relationships between these unique haplotypes and the samples, we may use the `haplotype_tbl` function:

```{r}
haplotype_tbl(geophagus, clean= TRUE, collapseSubstrings = TRUE, verbose = FALSE)
```

You may also collapse other types of information by using `collapse_others`. We can collapse our metadata to see which species and sampling localities are associated with each haplotype:

```{r}
haps_df <- haplotype_tbl(geophagus, verbose = FALSE)

collapse_others(data= geophagus_info, 
                hap_tbl= haps_df, 
                labels= "gbAccession", 
                cols= c("scientificName", "country"))
```

## Running species delimitation analysis

After preparing your data (alignments and phylogenetic trees), the next step it to run species delimitation 
analyses and combine them into a single `tbl_df`. Please check [Installing Species Delimitation Software](https://legallab.github.io/delimtools/articles/install.html) to know which sofware `delimtools` 
support. Check the examples below.

### ABGD

We can run ABGD by using the `abgd_tbl` function. This function requires a PATH for a FASTA file as input for
analysis and a PATH for the ABGD executable:

```{r}
dat_all_ali <- here::here("vignettes/geophagus.fasta")

abgd_df <- abgd_tbl(infile= dat_all_ali, 
                    exe= "/usr/local/bin/abgd",
                    model= 3,
                    outfolder= here::here("vignettes"),
                    haps= haps_df$labels)
                    
```

Then we can check `abgd_df`

```{r}
print(abgd_df)
```

### ASAP

We can run ASAP by using the `asap_tbl` function. This function requires a PATH for a FASTA file as input for
analysis and a PATH for the ASAP executable:

```{r}
asap_df <- asap_tbl(infile= dat_all_ali,
                    exe= "/usr/local/bin/asap",
                    haps= haps_df$labels,
                    outfolder = here::here("vignettes"),
                    model= 3)

print(asap_df)

```

**Note:** You should always indicate full PATH for `infile`, `exe`, and `outfolder` in ASAP for full functioning. 


### GMYC

We can run GMYC analysis by using the `splits` function `gmyc`. This function requires an ultrametric tree file
of class `phylo` as input for analysis. We can convert our `geophagus_beast` `r class(geophagus_beast)` object
into a `phylo` object by using `ape::as.phylo`:

```{r results='hide'}
gmyc_res <- splits::gmyc(as.phylo(geophagus_beast), method= "single")
```

Now, lets check the `summary`:

```{r}
summary(gmyc_res)
```

GMYC outputs a list containing several results. We can use `gmyc_tbl` to extract the clusters in a `tbl_df` format:

```{r}
gmyc_df <- gmyc_tbl(gmyc_res)

print(gmyc_df)

```

### bGMYC

We can run bGMYC analysis by using the `bGMYC` function `bgmyc.singlephy`. This function requires an ultrametric tree file of class `phylo` as input for analysis. We can convert our `geophagus_beast` `r class(geophagus_beast)` object into a `phylo` object by using `ape::as.phylo`:

```{r results='hide'}
bgmyc_res <- bGMYC::bgmyc.singlephy(as.phylo(geophagus_beast),
                                    mcmc= 11000,
                                    burnin= 1000,
                                    thinning= 100,
                                    t1= 2,
                                    t2= Ntip(as.phylo(geophagus_beast)),
                                    start= c(1, 0.5, 50))
```

bGMYC outputs a list containing several results. We can use `bgmyc_tbl` to extract the clusters in a `tbl_df` format using `0.05` as posterior probability threshold for clustering samples into species partitions:

```{r}
bgmyc_df <- bgmyc_tbl(bgmyc_res, ppcutoff = 0.05)

print(bgmyc_df)

```

### PTP and mPTP

We can run both PTP and mPTP analysis by using the `mptp_tbl`. This function requires a PATH for a phylogram as input for analysis, a PATH for the mptp executable, a string specifying which method to use ("multi" for mPTP; "single" for PTP), and a minimum branch length (minbrlen) for computations:

```{r}
mptp_df <- mptp_tbl(infile= here::here("vignettes/geophagus_raxml.nwk"),
                    exe= "/usr/local/bin/mptp",
                    method= "multi",
                    minbrlen= 2e-06,
                    outfolder = here::here("vignettes"),
                    delimname = "mptp")
```

```{r}
ptp_df <- mptp_tbl(infile= here::here("vignettes/geophagus_raxml.nwk"),
                   exe= "/usr/local/bin/mptp",
                   method= "single",
                   minbrlen= 2e-06,
                   outfolder = here::here("vignettes"),
                   delimname = "ptp")
```


To estimate a minimum branch length for your dataset, use `minbr_len`:

```{r}
min_brlen(as.phylo(geophagus_raxml))
```

### Local Minima

We can run the Local Minima analysis by using the `spider` function `localMinima`. This function requires a genetic distance matrix as input for analysis:

```{r}
mat <- dist.dna(geophagus, model= "raw", pairwise.deletion = TRUE)

lmin <- spider::localMinima(mat)

```

We can plot the `lmin` object to select the threshold. We will use the first value of the `lmin` object:

```{r fig.height= 3.5, fig.width= 6.9}
plot(lmin) |> abline(v=lmin$localMinima[1],col="red")
```

Since `Local Minima` output is a numeric vector, we need to use `locmin_tbl` to get our species partitions in a `tbl_df` format:

```{r}
locmin_df <- locmin_tbl(mat, 
                        threshold= lmin$localMinima[1],
                        haps= haps_df$labels)

print(locmin_df)
```

We can also use patristic distances to generate species partitions as well. Using the `geophagus_beast` tree, we can apply a threshold to classify tips of the tree by using its branch lengths:

```{r fig.height= 3.5, fig.width= 6.9}
tr_mat <- ape::cophenetic.phylo(as.phylo(geophagus_beast)) |> as.dist()

tr_lmin <- spider::localMinima(tr_mat)

plot(tr_lmin) |> abline(v=tr_lmin$localMinima[1],col="red")

treedist_df <- locmin_tbl(tr_mat,
                          threshold = tr_lmin$localMinima[1],
                          delimname = "treedist")

print(treedist_df)
```

## Fixed threshold

We can use `locmin_tbl` to create a species partition using a fixed threshold. For example, we can use a threshold of 2% to generate species partitions:

```{r}
percent_df <- locmin_tbl(mat, threshold = 0.02, haps= haps_df$labels, delimname = "percent")

print(percent_df)
```

### Morphology

We can also turn species ranks or results from morphological analysis into a species partition by using `morph_tbl`. For `geophagus` dataset, we will use the scientific names in `geophagus_info`:

```{r}
morph_df <- morph_tbl(labels= geophagus_info$gbAccession, 
                      sppVector= geophagus_info$scientificName) |>
  dplyr::filter(labels %in% haps_df$labels)

print(morph_df)
```

## Joining Species Delimitation Outputs

Since we have several species partitions, we need to merge them into a single data frame in order to visualize the results. However, since each method has its own rankings, we need to recode them prior to any further analysis. For this task, we can use `delim_join`. This function takes a `list` of species partitions as input in order to merge and recode all species partitions:

```{r message= FALSE}
all_delims <- list(abgd_df, asap_df, bgmyc_df, gmyc_df, 
                   locmin_df, morph_df, mptp_df, ptp_df, 
                   percent_df, treedist_df)

all_delims_df <- delim_join(all_delims)

```

We can summarise the `all_delims_df` object by using the `report_delim` function:

```{r}
report_delim(all_delims_df)
```

We can also check the match ratio statistics of Ahrens et al (2014) using `match_ratio`:

```{r}
match_ratio(all_delims_df) |> 
  dplyr::arrange(dplyr::desc(match_ratio)) |> 
            print(n=Inf)
```

By checking the results, all comparisons including treedist have a low `match_ratio`. Since species partitions with very low `match_ratio` values can impact consensus calculations, we will remove treedist before visualizing our results 

```{r}
all_delims_df <- dplyr::select(all_delims_df, -treedist)

report_delim(all_delims_df)
```

## Visualizing Results

We can visualize the results by using `delim_autoplot`. This function will plot a phylogenetic tree alongside with the results contained in `all_delims_df`. We will use the `geophagus_beast` tree to visualize the results:

```{r message= FALSE, fig.height= 15, fig.width= 12}

# customize tip labels of the tree
tip_tab <- geophagus_info |> 
  dplyr::filter(gbAccession %in% geophagus_beast@phylo$tip.label) |>
  dplyr::mutate(labs= glue::glue("{gbAccession} | {scientificName}")) |> 
  dplyr::select(gbAccession, labs, scientificName)

# create a customized color palette
cols <- delim_brewer(delim= all_delims_df, package="randomcoloR", seed=42)

# plot
delim_autoplot(all_delims_df, 
               geophagus_beast,
               consensus= TRUE,
               n_match = 5,
               tbl_labs= tip_tab,
               col_vec= cols,
               hexpand= 0.7,
               widths = c(0.5, 0.5))
```


